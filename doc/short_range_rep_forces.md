This is a classic "stiff" numerical problem. Because the physical gap ($0.686 \text{ cm}$) minus the particle diameter ($0.635 \text{ cm}$) leaves only $\approx 0.05 \text{ cm}$ of total play, and the security zone $\rho$ is $\approx 0.068 \text{ cm}$, the particles are **permanently** inside the activation zone of the front and back walls.

If you implement this naively, the repulsive forces from the front and back walls will sum to a non-zero value that fluctuates wildly with small position changes, acting like a compressed spring that wants to explode.

Here is a robust implementation plan specifically for this **"oversized security zone"** scenario.

---

### Phase 1: Separation of Regimes
Do not treat all collisions equally. You must separate the logic for **Lateral Interactions** ($x, z$ directions) and **Transverse Confinement** ($y$ direction).

*   **Regime A: Particle-Particle (P-P) & Side Walls:** Standard collision logic. Occurs occasionally.
*   **Regime B: Front/Back Walls:** Continuous confinement. Occurs constantly.

### Phase 2: The "Potential Well" Approach for Front/Back Walls
Since the particle is always within $\rho$ of the front/back walls, treat the wall forces not as "collisions" but as a **continuous background potential field**.

**1. Calculate Net Transverse Force:**
Instead of calculating Wall A and Wall B separately and risking numerical noise, calculate the net centering force analytically for the $y$-component.

Let $y$ be the particle center coordinate ($0 < y < 0.686$).
*   $d_{front} = y - R$
*   $d_{back} = (D_{gap} - y) - R$

The net force in the $y$-direction is:
$$ F_{y, net} = F_{repulsion}(d_{back}) - F_{repulsion}(d_{front}) $$

**2. Analytical Stabilization (Damping):**
Because this acts like a stiff spring, the particle will oscillate violently in the $y$-direction (the "rattle"). You **must** add a damping term specific to the $y$-axis to mimic the lubrication squeeze-film effect that prevents the rattle:
$$ F_{y, total} = F_{y, net} - \gamma v_y $$
*   Where $\gamma$ is a damping coefficient. This prevents the "blow up" by dissipating the kinetic energy generated by the artificial spring potential.

---

### Phase 3: Spatial Partitioning (Optimization)
Since the bed is effectively 2D, a full 3D neighbor search is wasteful.

**1. 2D Binning (Cell Linked List):**
*   Create a 2D grid in the $x-z$ plane only.
*   Bin size $\approx 2R + \rho$.
*   Since there is only one layer of particles in $y$, you never need to check for neighbors in the $y$-direction.

**2. The Interaction List:**
*   For Particle $i$:
    *   **Always** calculate Front/Back wall forces (Phase 2 logic).
    *   **Search** neighbors in adjacent $x-z$ bins.
    *   Calculate P-P forces and Side Wall ($x$-boundary) forces using the standard Equation 2.1.

---

### Phase 4: Time Integration (Preventing Blow-up)
This is the most critical step. The fluid solver runs at $\Delta t_{fluid} = 10^{-3} \text{s}$. The repulsive forces are too stiff for this timestep.

**Use Sub-Cycling (Time-Splitting):**
Do not force the collision physics to run at the fluid's speed. Update the particle position using a much smaller timestep ($\delta t$) while holding the fluid forces constant.

**Algorithm Pseudocode:**

```python
dt_fluid = 0.001
dt_collision = dt_fluid / 20  # Run physics 20x faster than fluid

for fluid_step in range(total_steps):
    
    # 1. Solve Fluid (Navier-Stokes) to get Fluid Drag/Lift Forces
    F_hydro = calculate_hydrodynamic_forces()
    
    # 2. Sub-cycle Particle Motion
    for sub_step in range(20):
        
        # A. Clear Forces
        F_total = F_hydro + F_gravity
        
        # B. Continuous Y-Confinement (Front/Back Walls)
        # Note: This is always active!
        F_total.y += calculate_potential_well_force(particle.y)
        F_total.y -= damping * particle.vy  # Crucial damping
        
        # C. Discrete Collisions (Neighbor Search)
        # Only check neighbors in X-Z grid
        for neighbor in get_neighbors_2D(particle):
            dist = distance(particle, neighbor)
            if dist < 2*R + rho:
                F_rep = calculate_repulsion(dist)
                F_total += F_rep
        
        # D. Side Wall Collisions (X-walls)
        if particle.x < R + rho:
            F_total.x += calculate_wall_repulsion(particle.x)
        
        # E. Explicit Integration (Verlet or Adams-Bashforth)
        particle.v += (F_total / mass) * dt_collision
        particle.pos += particle.v * dt_collision
        
    # 3. Update Fluid-Solid Coupling (DLM) using new particle positions
```

### Phase 5: Handling the "Shift Ratio"
The paper admits that this model reduces drag because the particle is artificially centered (away from the wall where shear is highest).

**Implementation Tip:**
If you want to match the *experimental* results better than the paper did without post-processing (the shift ratio), you could implement a **Variable $\rho$**:
*   $\rho_{particle-particle} = 0.068 \text{ cm}$ (Keep standard for stability).
*   $\rho_{wall-front/back} = 0.01 \text{ cm}$ (Make the wall security zone smaller).

*Risk:* This requires an even smaller sub-cycling timestep $\delta t$ because the wall stiffness will effectively increase as $\rho$ decreases (due to the $1/\rho^2$ term).
